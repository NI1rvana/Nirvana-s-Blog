<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo | 并发教程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">

  
    <link rel="stylesheet" href="/css/public.css" />
    <link rel="stylesheet" href="/css/layout.css" />
    <link rel="stylesheet" href="/css/iconfont.css" />
    <link rel="stylesheet" href="/css/APlayer.min.css" />
    <script src="/js/APlayer.min.js"></script>
    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.pjax.min.js"></script>
  
  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `Hexo | 并发教程`
  </script>
<meta name="generator" content="Hexo 5.4.1"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"CSS学习(一)","path":"2022/03/20/CSS学习-一/"},{"title":"CSS学习(二)","path":"2022/03/27/CSS学习-二/"},{"title":"Docker","path":"2022/11/09/Docker/"},{"title":"Dubbo","cover":"imgs/cover5.webp","path":"2022/11/08/Dubbo/"},{"title":"HTML学习(一)","path":"2022/03/14/HTML学习-一/"},{"title":"HTML学习(二)","path":"2022/03/14/HTML学习-二/"},{"title":"JVM","path":"2022/12/05/JVM/"},{"title":"Linux Nginx学习","path":"2022/10/25/Linux Nginx/"},{"title":"Mango学习(二)","cover":"imgs/cover2.webp","path":"2022/10/30/Mango学习-二/"},{"title":"Maven学习","path":"2022/10/14/Maven学习/"},{"title":"Mango学习(一)","cover":"imgs/cover2.webp","path":"2022/10/30/MongoDB/"},{"title":"MySQL实战45讲","path":"2023/01/02/MySQL实战45讲/"},{"title":"Redis学习","path":"2022/10/26/Redis学习/"},{"title":"SpringMVC+SpringBoot学习","cover":"imgs/cover3.webp","path":"2022/10/15/SpringMSV学习/"},{"title":"SQL，jdbc，MybatisPlus","path":"2022/10/22/SQL/"},{"title":"RabbitMQ","path":"2022/11/09/RabbitMQ/"},{"title":"Spring Franework","cover":"imgs/cover3.webp","path":"2022/10/13/Spring学习/"},{"title":"Tomcat核心原理","cover":"imgs/cover4.webp","path":"2022/11/06/Tomcat核心原理/"},{"title":"Vue入门","path":"2022/12/09/Vue入门/"},{"title":"Git学习","path":"2022/10/16/git学习/"},{"title":"Zookeeper","cover":"imgs/cover5.webp","path":"2022/11/09/zookeeper/"},{"title":"个人对于前端岗位的理解","path":"2022/02/27/个人对于前端岗位的理解/"},{"title":"并发教程","path":"2022/12/19/并发教程/"},{"title":"微服务技术栈(二)","path":"2022/12/02/微服务技术栈-二/"},{"title":"微服务技术栈(一)","path":"2022/11/20/微服务技术栈(一)/"},{"title":"小知识","path":"2022/10/26/杂文/"},{"title":"数据库系统概论","cover":"imgs/cover3.webp","path":"2022/11/05/数据库系统概论/"},{"title":"计算机网络(一)","cover":"imgs/cover1.webp","path":"2022/10/30/计算机网络-一/"},{"title":"计算机网络(二)","cover":"imgs/cover1.webp","path":"2022/12/12/计算机网络-二/"},{"title":"设计模式(一)","path":"2022/12/02/设计模式(一)/"},{"title":"领域驱动设计DDD","path":"2022/12/15/领域驱动设计DDD/"},{"title":"设计模式(二)","path":"2022/12/03/设计模式-二/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">Nirvana</p>
        <div class="main-left--tags">
          <span class="main-left--tag">学习</span>
          <span class="main-left--tag">摆烂</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“花有重开日，人无再少年”</p>
        <p>“一个简单普通的男孩”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a href=""><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>16</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>13</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>6 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>32 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>297天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <style>
pre::-webkit-scrollbar {
  width: 5px;
  height: 10px;
  background-color:#F5F5F5;
}
/*定义滚动条轨道
内阴影+圆角*/
pre::-webkit-scrollbar-track {
  background-color:#F5F5F5;
}
/*定义滑块
内阴影+圆角*/
pre::-webkit-scrollbar-thumb {
  background-color: rgb(69, 83, 100);
}

pre:active {
  background-color: rgb(81, 95, 116);
}
</style>

<div class="article-container">
  <div class="article">
    <h1 class="article-title">并发教程</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            
          </div>
          
          <p class="article-info--date">日期：2022-12-19 10:41:53</p>
        </div>
        <img src="/imgs/default-cover.webp" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content">
      <h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序由指令和数据组成</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这是就开启了一个进程</li>
<li>进程就可以是为程序的一个实例，大部分程序可以同时运行多个实例进程，也有的只能启动一个</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>一个进程之内可以分为一到多个线程</li>
<li>一个线程就是一个指令流，将指令流以一条条指令按顺序交给CPU执行</li>
<li>Java中，线程作为最小的调度单位，进程作为资源分配的最小单位。windows中进程是不活动的，只是作为线程的容器</li>
</ul>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li>进程之间独立，而线程存在于进程之内</li>
<li>进程拥有共享的资源，如内存空间等，供其内部线程共享</li>
<li>进程通信在同一计算机中称为IPC，不同计算机之间需要通过网络遵守协议</li>
<li>线程通信简单，且线程更轻盈，上下文切换成本低</li>
</ul>
<h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>单核cpu下，线程是串行执行。通过任务调度器，将cpu的时间片分给不同线程使用。将线程轮流使用cpu的做法称为并发。</p>
<p> 多核cpu下，每个核都可以调度运行线程，这时候线程是可以并行的</p>
<ul>
<li>并发是同一时间应对多件事情的能力</li>
<li>并行是同一时间做多件事情的能力</li>
</ul>
<h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><ul>
<li>需要等待结果返回，才能继续运行的就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以让方法变为异步，不需要消耗时间等待    </p>
<h2 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//直接使用thread</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//要执行的任务</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">//启动</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Runnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//要执行的任务</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 创建线程对象</span>
<span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//启动线程</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Thread与Runnable区别"><a href="#Thread与Runnable区别" class="headerlink" title="Thread与Runnable区别"></a>Thread与Runnable区别</h4><ul>
<li>方法一把任务和线程合并，而方法二把线程和任务分开</li>
<li>runnable更容易与线程池等高级api配合</li>
<li>runnable让任务类脱离了thread继承体系，更灵活</li>
</ul>
<h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>线程使用栈内存，每个线程启动后，虚拟机就会为其分配一块内存</p>
<ul>
<li>每个栈由多个栈帧组成，对应每次方法调用时所占用的内存</li>
<li>每个线程只能由一个活动栈帧，对应正在执行的方法</li>
</ul>
<h4 id="线程上下文切换-（Thread-cintext-switch）"><a href="#线程上下文切换-（Thread-cintext-switch）" class="headerlink" title="线程上下文切换  （Thread cintext switch）"></a>线程上下文切换  （Thread cintext switch）</h4><p>因为一些原因cpu不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的时间片用完</li>
<li>垃圾回收</li>
<li>出现更高优先级的线程需要运行</li>
<li>线程自己调用了sleep等方法</li>
</ul>
<p>发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，java中对应的概念是<strong>程序计数器</strong>，作用是记住吓一跳jvm指令的地址，是线程私有的</p>
<ul>
<li>频繁发生会影响性能</li>
<li>状态包括程序计数器、栈帧信息</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul>
<li>线程优先级会提示调度器优先调度该线程，但仅仅是提示</li>
<li>如果 cpu比较忙，那么由优先级高的有更高几率获得时间片</li>
</ul>
<h3 id="join方法-详解"><a href="#join方法-详解" class="headerlink" title="join方法 详解"></a>join方法 详解</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>等待某个线程结束</p>
<h4 id="限时同步"><a href="#限时同步" class="headerlink" title="限时同步"></a>限时同步</h4><p><code>join(long n)</code></p>
<p>最多等待n毫秒</p>
<h3 id="interrupt方法-详解"><a href="#interrupt方法-详解" class="headerlink" title="interrupt方法 详解"></a>interrupt方法 详解</h3><p>打断正常运行或被阻塞的线程</p>
<h3 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h3><p><img src="/images/image-20221223173331276.png" alt="image-20221223173331276"></p>
<h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><ul>
<li>使用stop()方法停止线程<ul>
<li>stop会真正杀死线程,如果这是线程锁住了共享资源,被杀死后就没有机会释放锁</li>
</ul>
</li>
<li>使用System.exit(int)方法停止线程<ul>
<li>目的仅是停止一个线程,但这种做法会让整个线程停止</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20221223174247077.png" alt="image-20221223174247077"></p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>默认情况下,java进程需要等到所有进程都结束之后才能结束.有一种特殊的进程叫做守护进程.只要其他非守护线程都结束了,守护线程就会强制结束</p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat和Poller线程都是守护线程</li>
</ul>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul>
<li>初始状态:创建了线程对象,还未和操作系统线程关联</li>
<li>可运行状态(就绪状态):线程已经被创建, 可以由CPU调用执行</li>
<li>运行状态:获取了CPU时间片</li>
<li>终止状态:调用了阻塞api,导致上下文切换,进入了阻塞状态.而后会变成就绪状态</li>
<li>阻塞状态:线程已经执行完毕,不会转变为其他状态</li>
</ul>
<h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><h3 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问“共享资源”<ul>
<li>多个线程读共享资源也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区</li>
</ul>
</li>
</ul>
<h4 id="竟态条件"><a href="#竟态条件" class="headerlink" title="竟态条件"></a>竟态条件</h4><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之发生了竟态条件</p>
<h3 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h3><p>为了避免临界区的竟态条件发生，有多种手段可以达到目的</p>
<ul>
<li>阻塞式解决方案：synchronized Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">synchronized</span><span class="token punctuation">(</span>对象<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	临界区
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="方法上的synchronized"><a href="#方法上的synchronized" class="headerlink" title="方法上的synchronized"></a>方法上的synchronized</h3><p> <img src="/images/image-20221224190441520.png" alt="image-20221224190441520"></p>
<h3 id="变量线程安全分析"><a href="#变量线程安全分析" class="headerlink" title="变量线程安全分析"></a>变量线程安全分析</h3><h4 id="成员变量和静态变量是否线程安全"><a href="#成员变量和静态变量是否线程安全" class="headerlink" title="成员变量和静态变量是否线程安全"></a>成员变量和静态变量是否线程安全</h4><ul>
<li>若没有共享，则安全</li>
<li>如果被共享了，则根据状态是否能改变分情况<ul>
<li>只有读操作，则安全</li>
<li>如果有读写，则代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="局部变量是否线程安全"><a href="#局部变量是否线程安全" class="headerlink" title="局部变量是否线程安全"></a>局部变量是否线程安全</h4><ul>
<li>是线程安全的</li>
<li>但局部变量引用的对象未必<ul>
<li>如果对象没有逃离方法的作用范围，则是安全</li>
<li>若是对象讨论方法的作用范围，则需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h4><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>java.util.concurrent</li>
</ul>
<p>他们的方法是原子的</p>
<p>但多个方法组合不是原子的</p>
<h3 id="Monitor概念"><a href="#Monitor概念" class="headerlink" title="Monitor概念"></a>Monitor概念</h3><h4 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h4><p> 以32为虚拟机为例</p>
<p>普通对象</p>
<p><img src="/images/image-20221225154827344.png" alt="image-20221225154827344"></p>
<p>数组对象</p>
<p><img src="/images/image-20221225154846330.png" alt="image-20221225154846330"></p>
<p>其中mark word结构为 </p>
<p><img src="/images/image-20221225155012487.png" alt="image-20221225155012487"></p>
<h3 id="Monitor（锁）"><a href="#Monitor（锁）" class="headerlink" title="Monitor（锁）"></a>Monitor（锁）</h3><p>Monitor被翻译为监视器</p>
<p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁之后，该对象头的Mark Word种就被设置指向Monitor对象的指针</p>
<h4 id="Monitor结构如下"><a href="#Monitor结构如下" class="headerlink" title="Monitor结构如下"></a>Monitor结构如下</h4><p><img src="/images/image-20221225161327520.png" alt="image-20221225161327520"></p>
<ul>
<li>一开始Owner 为null</li>
<li>有线程锁住后owner会设置为上锁的线程，之后的线程进入EntryList Bloked</li>
<li>当前线程执行完同步代码块的内容，唤醒EntryList中等待的线程来竞争锁</li>
</ul>
<h3 id="Synchronized原理进阶"><a href="#Synchronized原理进阶" class="headerlink" title="Synchronized原理进阶"></a>Synchronized原理进阶</h3><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（没有竞争），那么可以使用轻量级锁来优化</p>
<p>轻量级锁对使用者是透明的，即语法仍然是synchronized</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<p><img src="/images/image-20221225172650728.png" alt="image-20221225172650728"></p>
<p><img src="/images/image-20221225173911273.png" alt="image-20221225173911273"></p>
<ul>
<li>创建锁记录(Lock Record)对象,每个线程都会包含一个锁记录的结构,内部可以存储锁定对象的Mark Word</li>
<li>让锁记录中Object reference指向锁对象,并尝试用cas替换Object的Mark Word,将Mark Word的值存入锁记录</li>
<li>如果替换成功,对象头中储存了<code>锁记录地址和状态00</code>,表示由该线程给对象加锁</li>
<li>如果cas失败,有两种情况<ul>
<li>如果有其他线程已经持有了Object的轻量级锁,这是表明有竞争,进入<code>锁膨胀</code>过程</li>
<li>如果是自己执行了synchronized锁重入,那么再添加一条Lock Record作为重入的计数</li>
</ul>
</li>
<li>当退出synchronized代码块(解锁时),如果取值有为null的所记录,表示有重入,这是重置锁记录,表示重入计数减一</li>
<li>当不为null,这是使用cas将Mark Word的值恢复给对象头<ul>
<li>成功则表示解锁成功</li>
<li>失败表示轻量级锁进行了锁膨胀或已经升级为重量级锁,进入重量级锁流程</li>
</ul>
</li>
</ul>
<h4 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h4><p>若在尝试加轻量级锁的过程中,cas操作无法成功没这事一种情况就是有其他线程为此对象加上了轻量级锁,这是需要进行锁膨胀,将轻量级锁变成重量级锁</p>
<ul>
<li>当Thread-1进行轻量级加锁时,Thread-0已经对该对象加了轻量级锁</li>
<li>当加锁失败时候,进入锁膨胀流程<ul>
<li>Object对象申请Monitor锁,让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList Blocked </li>
</ul>
</li>
<li>当thread-0退出同步块解锁时,使用cas将Mark Word的值恢复给对象头,失败.这是会进入重量级锁流程,即按照Monitor地址找到Monitor对象,设置Owner为null,唤醒EntryList种Blocked线程</li>
</ul>
<h4 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h4><p>重量级锁竞争的时候,还可以使用自旋来进行优化,如果当前线程自选成功(即这时候持锁线程已经推出了同步块,释放了锁),这时当前线程就可以避免阻塞</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>轻量级锁在没有竞争时,每次重入仍然需要执行cas操作</p>
<p>Java6种引入了偏向锁来做进一步优化:只有第一次使用cas将线程id设置到对象的Mark Word,之后发现这个线程ID是自己的就表示没有竞争,不用重新cas,以后只要不发生竞争,这个对象就归该线程所有.</p>
<p> <img src="/images/image-20221228190032695.png" alt="image-20221228190032695"></p>
<p>一个对象创建时</p>
<ul>
<li>如果开启了偏向锁，创建后markword值为0x05，即最后三位101，这是thread、epoch、age都是0</li>
<li>偏向锁是默认是延迟的，不会再程序启动时立刻生效，可以手动更改</li>
<li>如果没有开启偏向锁，对象创建后，markword值为0x01，即最后三位是001，hashcode和age都是0</li>
</ul>
<h4 id="批量重定向"><a href="#批量重定向" class="headerlink" title="批量重定向"></a>批量重定向</h4><p>如果对象虽然被多个线程访问，但没有竞争。这是偏向了T1的对象仍然有机会偏向T2，重偏向会充值对象的Thread ID</p>
<p>当撤销偏向锁与之超过20次后，jvm会重新偏向</p>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>撤销超过40次之后，将整个类的所有对象变为不可偏向</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>jvm自动进行锁消除操作</p>
<h3 id="Wait-notify"><a href="#Wait-notify" class="headerlink" title="Wait/notify"></a>Wait/notify</h3><ul>
<li>owner线程发现条件不满足，调用wait方法，即可进入waitset变为Waiting状态</li>
<li>Blocked和Waiting的线程都处于阻塞状态，不占用CPU</li>
<li>Blocked线程会在Owner线程释放时环形</li>
<li>Waiting线程会在owner线程调用notify或notifyall时唤醒，但唤醒后不意味着立刻得到锁，仍需进入entrylist重新竞争</li>
</ul>
<h4 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h4><ul>
<li><code>obj.wait()</code>进入object监视器的线程到waitset等待</li>
<li><code>obj.wait(long n )</code>进入object监视器的线程到waitset等待(有时限的等待)</li>
<li><code>obj.notify()</code>在object上正在waitset等待的线程挑一个唤醒</li>
<li><code>obj.notifyAll()</code>全部唤醒</li>
</ul>
<p>必须获得此对象的锁还能调用这几个方法</p>
<h4 id="使用wait和notify"><a href="#使用wait和notify" class="headerlink" title="使用wait和notify"></a>使用wait和notify</h4><h5 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h5><p><img src="/images/image-20221228215449401.png" alt="image-20221228215449401"></p>
<h3 id="保护性暂停模式"><a href="#保护性暂停模式" class="headerlink" title="保护性暂停模式"></a>保护性暂停模式</h3><p>即Guarded Suspension ，用在一个线程等待另一个线程的结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程，可以使用消息队列</li>
<li>JDK中，join的实现，future的实现都是基于此模式</li>
<li>同步模式</li>
</ul>
<p><img src="/images/image-20221229005843079.png" alt="image-20221229005843079"></p>
<h3 id="异步模式之生产者消费者"><a href="#异步模式之生产者消费者" class="headerlink" title="异步模式之生产者消费者"></a>异步模式之生产者消费者</h3><p><img src="/images/image-20221229020204437.png" alt="image-20221229020204437"></p>
<h3 id="Park-amp-Unpark"><a href="#Park-amp-Unpark" class="headerlink" title="Park &amp; Unpark"></a>Park &amp; Unpark</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//暂停当前线程</span>
<span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//恢复某个线程的运行</span>
<span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>暂停线程对象<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>wait,notify和notifyall必须配合ObjectMonitor一起使用,而park和unpark不用</li>
<li>park和unpark是以线程为单位来阻塞和唤醒线程,而notify只是随机唤醒一个等待线程</li>
<li>park &amp; unpark可以先unpark,而wait和notify不能先notify</li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p><img src="/images/image-20221229020810019.png" alt="image-20221229020810019"></p>
<h3 id="线程转换"><a href="#线程转换" class="headerlink" title="线程转换"></a>线程转换</h3><p><img src="/images/image-20221229150718573.png" alt="image-20221229150718573"></p>
<h4 id="new-gt-Runnable"><a href="#new-gt-Runnable" class="headerlink" title="new -&gt; Runnable"></a>new -&gt; Runnable</h4><p>调用线程的start方法</p>
<h4 id="Runnable-gt-Waiting"><a href="#Runnable-gt-Waiting" class="headerlink" title="Runnable -&gt; Waiting"></a>Runnable -&gt; Waiting</h4><p>线程用synchronized(obj)获取对象锁之后</p>
<ul>
<li>调用obj.wait()方法时,线程从Runnable -&gt; Waiting</li>
<li>调用obj.notify(),obj.notifyall().t.interrupt()时<ul>
<li>竞争锁成功,线程从waiting-&gt;Runnable</li>
<li>失败,从waiting -&gt; Blocked</li>
</ul>
</li>
</ul>
<h4 id="Runnable-gt-Waiting-1"><a href="#Runnable-gt-Waiting-1" class="headerlink" title="Runnable -&gt; Waiting"></a>Runnable -&gt; Waiting</h4><ul>
<li>当前线程调用join方法,当前线程从runnbale -&gt; waiting</li>
<li>t线程运行结束,或调用了当前线程的interrupt时,当前线程waiting -&gt; runnable</li>
</ul>
<h4 id="Runnbale-gt-timed-waiting"><a href="#Runnbale-gt-timed-waiting" class="headerlink" title="Runnbale -&gt; timed_waiting"></a>Runnbale -&gt; timed_waiting</h4><p>线程用synchronized(obj)获取了对象锁</p>
<ul>
<li>调用obj.wait(long n)方法,线程从runnbale -&gt; timed_waiting</li>
<li>线程等待时间超过了n毫秒,或调用notify notifyall interrupt时<ul>
<li>竞争锁成功,t线程从timed_waiting -&gt; runnable</li>
<li>竞争锁失败 从Timed_waiting -&gt; blocked </li>
</ul>
</li>
</ul>
<p><img src="/images/image-20221229180654810.png" alt="image-20221229180654810"></p>
<ul>
<li>当前线程调用sleep,当前线程从 Runnable-&gt;timed_waiting</li>
<li>当前线程等待超过了n毫秒,从Timed_waiting -&gt; runnable</li>
</ul>
<p><img src="/images/image-20221229181024543.png" alt="image-20221229181024543"></p>
<h4 id="runnable-gt-blocked"><a href="#runnable-gt-blocked" class="headerlink" title="runnable -&gt; blocked"></a>runnable -&gt; blocked</h4><ul>
<li>线程用synchronized(obj)获取了对象锁时如果竞争失败,从runnbale-&gt;blocked</li>
<li>持obj锁线程的同步代码块执行完毕,会唤醒该对象上所有blocked的线程重新竞争,如果其中线程竞争成功,从blocked -&gt; runnbale 其他的仍然是blocked</li>
</ul>
<h4 id="Runnable-gt-Terminated"><a href="#Runnable-gt-Terminated" class="headerlink" title="Runnable -&gt; Terminated"></a>Runnable -&gt; Terminated</h4><p>当所有线程代码运行完毕,进入terminated</p>
<h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><h4 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h4><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>一个线程需要同时获取多个锁,这时就容易发生死锁</p>
<p>t1线程获得<code>A对象</code>锁,想获取<code>B对象</code>锁</p>
<p>t1线程获得<code>B对象</code>锁,想获取<code>A对象</code>锁</p>
<p>定位死锁</p>
<p>检测死锁可以用jconsole工具,或者用jps定位线程id,再用jstack定位死锁</p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>活锁出现在连个线程互相改变对方的结束条件,最后谁也无法结束</p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>一个线程由于优先级太低,始终得不到CPU调度执行,也不能够结束.</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>相对于synchronized</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
<li>都可以重入</li>
</ul>
<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><p>指同一个线程如果首次获得了这个锁,那么因为他是这把锁的拥有者,因此可以再次获得这把锁</p>
<p>如果不是可重入锁,第二次获得锁的时候,自己也会被挡住</p>
<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>在代码执行过程中,其他进程可以interrupt打断</p>
<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>立刻失败</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>ReentrantLock 默认是不公平</p>
<p>公平锁：按照进入阻塞队列的顺序来给锁</p>
<p>公平锁一般没有必要，会降低并发度</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p><img src="/images/image-20221229233238794.png" alt="image-20221229233238794"></p>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><h4 id="固定顺序-amp-交替输出"><a href="#固定顺序-amp-交替输出" class="headerlink" title="固定顺序&amp;交替输出"></a>固定顺序&amp;交替输出</h4><p>均可以用wait&amp;notify，park&amp;unpark</p>
<h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>JMM即Java Memory Model ，定义了主存、工作内存等抽象概念，底层对应着CPU寄存、缓存、硬件内存、CPU指令优化等</p>
<p>JMM体现在一下方面</p>
<ul>
<li>原子性-保证指令不会收到上下文切换的影响</li>
<li>可见性-保证指令不会收到cpu缓存的影响</li>
<li>有序性-保证指令不会受到cpu指令并行优化的影响</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><img src="/images/image-20221230182137695.png" alt="image-20221230182137695"></p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p><img src="/images/image-20221230182313796.png" alt="image-20221230182313796"></p>
<p><img src="/images/image-20221230182331562.png" alt="image-20221230182331562"></p>
<p><img src="/images/image-20221230182407075.png" alt="image-20221230182407075"></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p><code>volatile</code>易变关键字</p>
<p>可以修饰成员变量和静态成员变量 ，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存</p>
<h4 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h4><p><code>volatile</code>只能保证线程对一个变量的修改对另一个线程可见，但是无法保证原子性</p>
<p><code>synchronized</code>既可以保证原子性又可以保证可见性，但它是重量级操作，性能相对更低</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>JVM在不影响正确性的前提下，可以调整语句的执行顺序·</p>
<p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行</p>
<h4 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h4><p>底层实现原理是内存屏障，Memory  Barrier</p>
<ul>
<li>对volatile变量的写指令后会加入写屏障</li>
<li>对valatile变量的读指令前会加入读屏障</li>
</ul>
<h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><ul>
<li>写屏障保证在该屏障之前，对共享变量的改动，都同步到主存中</li>
<li>读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li>
</ul>
<h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><ul>
<li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会讲读屏障之后的代码排在读屏障之前 </li>
</ul>
<p>注： </p>
<ul>
<li>仅保证有序性、可见性，但不能解决指令交错</li>
<li>只能保证本线程内的代码</li>
</ul>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>happens-before 规定了对共享变量的写操作对其他线程的读操作可见，他是可见性与有序性的一套规则总结，抛开一下happens-before规则，jmm并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见</p>
<ul>
<li>线程解锁m之前对变量的写，对于接下来对m加锁的其他线程对该变量的读可见</li>
<li>线程对volatile变量的写，对接下来其他线程对该变量的读可见</li>
<li>start前的写，对于线程start后可见</li>
<li>线程结束前对变量的写，对其他线程得知它结束后的读可见       </li>
<li>线程t1打断线程2前对变量的写，对于其他线程得知t2被打断偶对变量的读可见</li>
</ul>
<h2 id="共享资源之无锁"><a href="#共享资源之无锁" class="headerlink" title="共享资源之无锁"></a>共享资源之无锁</h2><h3 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h3><h5 id="CAS-compareAndSet-，原子操作"><a href="#CAS-compareAndSet-，原子操作" class="headerlink" title="CAS - compareAndSet ，原子操作"></a>CAS - compareAndSet ，原子操作</h5><p>工作原理</p>
<p><img src="/images/image-20221231165557034.png" alt="image-20221231165557034"></p>
<h5 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h5><p>获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰</p>
<p>可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓冲中查找变量的值，必须到主存获取。线程操作volatile变量都是直接操作主存。</p>
<p>cas必须借助volatile才能读取到共享变量的最新值来实现比较并交换的效果</p>
<h4 id="为什么无锁效率高"><a href="#为什么无锁效率高" class="headerlink" title="为什么无锁效率高"></a>为什么无锁效率高</h4><p>无锁情况，即使重试失败，线程仍在高速运行，没有停歇。而synchronized会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p>
<h4 id="cas特点"><a href="#cas特点" class="headerlink" title="cas特点"></a>cas特点</h4><p>结合cas和volatile可以实现无锁并发，适用于线程数少、多核cpu场景下</p>
<ul>
<li>cas基于乐观锁的思想</li>
<li>synchronized基于悲观锁的思想</li>
<li>cas体现的是无锁并发、无阻塞并发 <ul>
<li>没有使用synchronized，所以不会阻塞，因此效率提升</li>
<li>但竞争激烈，重试必然频繁发生，效率反而受到影响</li>
</ul>
</li>
</ul>
<h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong </li>
</ul>
<h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference  </li>
</ul>
<h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray </li>
</ul>
<h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul>
<li>AtomicReferenceFieldUpdataer</li>
<li>AtomicIntegerFieldUpdataer</li>
<li>AtomicLongFieldUpdataer</li>
</ul>
<h3 id="原子更新器"><a href="#原子更新器" class="headerlink" title="原子更新器"></a>原子更新器</h3><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><p>关键域</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//累加单元 懒惰初始化</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cells<span class="token punctuation">;</span>

<span class="token comment">//基础值 如果没有竞争 则用cas累加这个域</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> base<span class="token punctuation">;</span>

<span class="token comment">//在cells创建或扩容时，置为1，表示加锁</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> cellsBusy<span class="token punctuation">;</span>
 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe对象提供了非常底层的，操作方法、线程的方法，Unsafe对象不能直接调用，只能通过反射获得</p>
<p><img src="/images/image-20230101002419109.png" alt="image-20230101002419109"></p>
<h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><p>保护性机制 - 在修改对象时创建新的对象</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h3 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h3><h4 id="设置final原理"><a href="#设置final原理" class="headerlink" title="设置final原理"></a>设置final原理</h4><p><img src="/images/image-20230101011013591.png" alt="image-20230101011013591"></p>
<p>字节码</p>
<p><img src="/images/image-20230101011002254.png" alt="image-20230101011002254"></p>
<p>final变量的赋值也会通过putfield指令来完成，在这条指令后加入写屏障，保证其他线程读到他的值时不会出现为0的情况</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>没有任何成员变量</p>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2022/12/19/并发教程/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程与线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">二者对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">2.</span> <span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">异步调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">创建和运行线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">4.1.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">4.1.2.</span> <span class="toc-text">方法二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E4%B8%8ERunnable%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">Thread与Runnable区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">线程运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="toc-number">4.2.1.</span> <span class="toc-text">栈与栈帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-%EF%BC%88Thread-cintext-switch%EF%BC%89"><span class="toc-number">4.2.2.</span> <span class="toc-text">线程上下文切换  （Thread cintext switch）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.3.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95-%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.4.</span> <span class="toc-text">join方法 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.4.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E6%97%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">4.4.2.</span> <span class="toc-text">限时同步</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt%E6%96%B9%E6%B3%95-%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">interrupt方法 详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">两阶段终止模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF"><span class="toc-number">4.6.1.</span> <span class="toc-text">错误思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.7.</span> <span class="toc-text">守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">4.8.</span> <span class="toc-text">线程状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">共享带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9F%E6%80%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text">竟态条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.2.</span> <span class="toc-text">synchronized 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized"><span class="toc-number">5.2.1.</span> <span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84synchronized"><span class="toc-number">5.3.</span> <span class="toc-text">方法上的synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">变量线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.4.1.</span> <span class="toc-text">成员变量和静态变量是否线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.4.2.</span> <span class="toc-text">局部变量是否线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-number">5.4.3.</span> <span class="toc-text">常见的线程安全类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.</span> <span class="toc-text">Monitor概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">5.5.1.</span> <span class="toc-text">java对象头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Monitor%EF%BC%88%E9%94%81%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">Monitor（锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B"><span class="toc-number">5.6.1.</span> <span class="toc-text">Monitor结构如下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6"><span class="toc-number">5.7.</span> <span class="toc-text">Synchronized原理进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">5.7.1.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-number">5.7.2.</span> <span class="toc-text">锁膨胀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-number">5.7.3.</span> <span class="toc-text">自旋优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">5.7.4.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.7.5.</span> <span class="toc-text">批量重定向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">5.7.6.</span> <span class="toc-text">批量撤销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">5.7.7.</span> <span class="toc-text">锁消除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wait-notify"><span class="toc-number">5.8.</span> <span class="toc-text">Wait&#x2F;notify</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.8.1.</span> <span class="toc-text">API介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify"><span class="toc-number">5.8.2.</span> <span class="toc-text">使用wait和notify</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">wait和sleep的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.9.</span> <span class="toc-text">保护性暂停模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">5.10.</span> <span class="toc-text">异步模式之生产者消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Park-amp-Unpark"><span class="toc-number">5.11.</span> <span class="toc-text">Park &amp; Unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">5.11.1.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">5.11.2.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.11.2.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.12.</span> <span class="toc-text">线程转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new-gt-Runnable"><span class="toc-number">5.12.1.</span> <span class="toc-text">new -&gt; Runnable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-gt-Waiting"><span class="toc-number">5.12.2.</span> <span class="toc-text">Runnable -&gt; Waiting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-gt-Waiting-1"><span class="toc-number">5.12.3.</span> <span class="toc-text">Runnable -&gt; Waiting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnbale-gt-timed-waiting"><span class="toc-number">5.12.4.</span> <span class="toc-text">Runnbale -&gt; timed_waiting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runnable-gt-blocked"><span class="toc-number">5.12.5.</span> <span class="toc-text">runnable -&gt; blocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-gt-Terminated"><span class="toc-number">5.12.6.</span> <span class="toc-text">Runnable -&gt; Terminated</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-number">5.13.</span> <span class="toc-text">多把锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-number">5.13.1.</span> <span class="toc-text">活跃性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.13.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">5.13.3.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF"><span class="toc-number">5.13.4.</span> <span class="toc-text">饥饿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">5.14.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">5.14.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">5.14.2.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">5.14.3.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">5.14.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.14.5.</span> <span class="toc-text">条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.15.</span> <span class="toc-text">同步模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%A1%BA%E5%BA%8F-amp-%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-number">5.15.1.</span> <span class="toc-text">固定顺序&amp;交替输出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98"><span class="toc-number">6.</span> <span class="toc-text">共享模型之内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">Java内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">原因分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7-vs-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">可见性 vs 原子性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.1.</span> <span class="toc-text">volatile原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">如何保证可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">如何保证有序性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#happens-before"><span class="toc-number">6.3.2.</span> <span class="toc-text">happens-before</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E4%B9%8B%E6%97%A0%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">共享资源之无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%B8%8Evolatile"><span class="toc-number">7.1.</span> <span class="toc-text">CAS与volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#CAS-compareAndSet-%EF%BC%8C%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">CAS - compareAndSet ，原子操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Volatile"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">7.1.1.</span> <span class="toc-text">为什么无锁效率高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cas%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.2.</span> <span class="toc-text">cas特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B4%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">原子整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">原子引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">原子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">字段更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">7.6.</span> <span class="toc-text">原子更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">7.7.</span> <span class="toc-text">原子累加器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LongAdder"><span class="toc-number">7.8.</span> <span class="toc-text">LongAdder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe"><span class="toc-number">7.9.</span> <span class="toc-text">Unsafe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">8.</span> <span class="toc-text">共享模型之不可变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.1.</span> <span class="toc-text">不可变设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">final原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEfinal%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">设置final原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81"><span class="toc-number">8.4.</span> <span class="toc-text">无状态</span></a></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2023/01/02/MySQL实战45讲/">MySQL实战45讲</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2022/12/15/领域驱动设计DDD/">领域驱动设计DDD</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>

<script src="/js/prism.js"></script>

<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2022/12/19/并发教程/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const as = tocs ? tocs.querySelectorAll('a') : []
    as.forEach(a => {
      a.addEventListener('click', e => {
        const href = decodeURIComponent(a.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      欢迎来到我的博客捏，记录着一些自己学习的知识内容，期待和大家的交流 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer">By Nirvana. </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const commentDom = document.querySelector('.turn-comment')
    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"卡","artist":"布","url":"达","cover":"/"},{"name":"暂","artist":"无","cover":"/"},{"name":"/","artist":"m","url":"u","cover":"/s"},{"name":"h","artist":"t","url":"t","cover":"/p"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  })
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }


    window.onload = function () {
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll()
          if (['/', '/log/', '/link/', '/about/', '/tools/'].includes(location.pathname) && window.innerWidth > 1200) {
            init && init('container') // 水波纹动画
          }
        }, 500)
      }, 500)
    }
    
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {fragment:'#main-container', timeout:8000})

    $(document).on('pjax:start', function() {
      // $('.main-container').hide()
    })
    $(document).on('pjax:complete', function() {
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
    })
    $(document).on('pjax:popstate', function() {
      // $('.main-container').fadeIn()
    })
  </script>
  
</body>
</html>